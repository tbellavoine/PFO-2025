<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>pfo-2025 documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
        <link rel="stylesheet" href="../styles/Laravel.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">pfo-2025 documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  Cell</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/pages/twenty-forty-eight/twenty-forty-eight.component.ts</code>
        </p>




        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#id" 
>
                                            id
                                        </a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#isNew" 
>
                                            isNew
                                        </a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#merged" 
>
                                            merged
                                        </a>
                                </li>
                                <li>
                                        <a href="#value" 
>
                                            value
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="id"></a>
                                        <span class="name "><b>id</b>
                                            <a href="#id">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>id:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="isNew"></a>
                                        <span class="name "><b>isNew</b>
                                            <a href="#isNew">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>isNew:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="merged"></a>
                                        <span class="name "><b>merged</b>
                                            <a href="#merged">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>merged:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="value"></a>
                                        <span class="name "><b>value</b>
                                            <a href="#value">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>value:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Component, computed, effect, HostListener, signal } from &#x27;@angular/core&#x27;;
import { NgClass } from &#x27;@angular/common&#x27;;

interface Cell {
  value: number;
  id: number;
  merged?: boolean;
  isNew?: boolean;
}

interface GameState {
  board: Cell[][];
  score: number;
  moves: number;
  canUndo: boolean;
}
@Component({
  selector: &#x27;app-twenty-forty-eight&#x27;,
  imports: [
    NgClass
  ],
  templateUrl: &#x27;./twenty-forty-eight.component.html&#x27;,
})
export class TwentyFortyEightComponent {
  public board &#x3D; signal&lt;Cell[][]&gt;(this.createEmptyBoard());
  public score &#x3D; signal(0);
  public bestScore &#x3D; signal(0);
  public moves &#x3D; signal(0);
  public gameOver &#x3D; signal(false);
  public gameWon &#x3D; signal(false);
  public isPlaying &#x3D; signal(false);
  public showDebug &#x3D; signal(false);
  public animating &#x3D; signal(false);
  public readonly gridSize &#x3D; 4;
  public readonly winTile &#x3D; 2048;
  private readonly animationDuration &#x3D; 150;
  private readonly newTileDelay &#x3D; 100;
  private previousState: GameState | null &#x3D; null;
  private cellIdCounter &#x3D; 0;
  public flatBoard &#x3D; computed(() &#x3D;&gt; this.board().flat());
  public hasEmptyCell &#x3D; computed(() &#x3D;&gt;
    this.flatBoard().some(cell &#x3D;&gt; cell.value &#x3D;&#x3D;&#x3D; 0)
  );

  public canMove &#x3D; computed(() &#x3D;&gt; {
    if (this.hasEmptyCell()) return true;
    return this.hasAvailableMoves();
  });

  public isGameOver &#x3D; computed(() &#x3D;&gt;
    !this.canMove() &amp;&amp; !this.gameWon()
  );

  public highestTile &#x3D; computed(() &#x3D;&gt;
    Math.max(...this.flatBoard().map(cell &#x3D;&gt; cell.value))
  );

  constructor() {
    this.loadBestScore();
    this.initializeGame();

    // Effect pour surveiller les changements de score
    effect(() &#x3D;&gt; {
      const currentScore &#x3D; this.score();
      if (currentScore &gt; this.bestScore()) {
        this.bestScore.set(currentScore);
        this.saveBestScore();
      }
    });

    // Effect pour détecter la fin de jeu
    effect(() &#x3D;&gt; {
      if (this.isGameOver()) {
        this.gameOver.set(true);
        this.isPlaying.set(false);
      }
    });

    // Effect pour détecter la victoire
    effect(() &#x3D;&gt; {
      if (!this.gameWon() &amp;&amp; this.highestTile() &gt;&#x3D; this.winTile) {
        this.gameWon.set(true);
      }
    });
  }

  /**
   * Gérer les événements de pression des touches
   * @param event
   */
  @HostListener(&#x27;window:keydown&#x27;, [&#x27;$event&#x27;])
  public handleKeyPress(event: KeyboardEvent): void {
    if (!this.isPlaying() || this.animating()) return;

    this.handleGameControls(event);
  }

  /**
   * Toggle the game state (play/pause)
   */
  public toggleGame(): void {
    this.isPlaying.set(!this.isPlaying());
  }

  /**
   * Initialiser une nouvelle partie
   */
  public initializeGame(): void {
    this.board.set(this.createEmptyBoard());
    this.addRandomTile();
    this.addRandomTile();
    this.isPlaying.set(true);
  }

  /**
   * Réinitialiser le jeu
   */
  public resetGame(): void {
    this.score.set(0);
    this.moves.set(0);
    this.gameOver.set(false);
    this.gameWon.set(false);
    this.previousState &#x3D; null;
    this.cellIdCounter &#x3D; 0;
    this.initializeGame();
  }

  /**
   * Déplacer les tuiles dans une direction donnée
   * @param direction
   */
  public move(direction: &#x27;up&#x27; | &#x27;down&#x27; | &#x27;left&#x27; | &#x27;right&#x27;): void {
    if (!this.canMove() || this.animating()) return;

    this.saveCurrentState();
    const moved &#x3D; this.performMove(direction);

    if (moved) {
      this.animating.set(true);
      this.moves.update(m &#x3D;&gt; m + 1);

      setTimeout(() &#x3D;&gt; {
        this.addRandomTile();
        this.animating.set(false);
      }, this.newTileDelay);
    }
  }

  /**
   * Annuler le dernier mouvement
   */
  public undoMove(): void {
    if (!this.previousState || this.animating()) return;

    this.board.set(this.copyBoard(this.previousState.board));
    this.score.set(this.previousState.score);
    this.moves.set(this.previousState.moves);
    this.previousState &#x3D; null;
  }

  /**
   * Ajouter une nouvelle tuile aléatoire (2 ou 4) sur le plateau
   */
  public addRandomTile(): void {
    const emptyCells &#x3D; this.getEmptyCells();
    if (emptyCells.length &#x3D;&#x3D;&#x3D; 0) return;

    const randomCell &#x3D; emptyCells[Math.floor(Math.random() * emptyCells.length)];
    const newValue &#x3D; Math.random() &lt; 0.9 ? 2 : 4;

    const newBoard &#x3D; this.copyBoard(this.board());
    newBoard[randomCell.row][randomCell.col] &#x3D; {
      value: newValue,
      id: this.getNextCellId(),
      isNew: true
    };

    this.board.set(newBoard);

    // Retirer le flag isNew après l&#x27;animation
    setTimeout(() &#x3D;&gt; {
      const currentBoard &#x3D; this.copyBoard(this.board());
      currentBoard[randomCell.row][randomCell.col].isNew &#x3D; false;
      this.board.set(currentBoard);
    }, this.animationDuration);
  }

  /**
   * Obtenir la liste des cellules vides sur le plateau
   * @returns
   */
  public getEmptyCells(): { row: number; col: number }[] {
    const emptyCells: { row: number; col: number }[] &#x3D; [];
    const currentBoard &#x3D; this.board();

    for (let row &#x3D; 0; row &lt; this.gridSize; row++) {
      for (let col &#x3D; 0; col &lt; this.gridSize; col++) {
        if (currentBoard[row][col].value &#x3D;&#x3D;&#x3D; 0) {
          emptyCells.push({ row, col });
        }
      }
    }

    return emptyCells;
  }

  /**
   * Vérifier si l&#x27;annulation est possible
   * @returns
   */
  public canUndo(): boolean {
    return this.previousState !&#x3D;&#x3D; null &amp;&amp; !this.animating();
  }

  /**
   * Formater le score avec des séparateurs de milliers
   * @param score
   */
  public formatScore(score: number): string {
    return score.toLocaleString();
  }

  /**
   * Obtenir la classe CSS pour une tuile en fonction de sa valeur
   * @param value
   * @returns
   */
  public getTileColor(value: number): string {
    const colors: { [key: number]: string } &#x3D; {
      0: &#x27;bg-primary&#x27;,
      2: &#x27;bg-primary-darken text-light&#x27;,
      4: &#x27;bg-grey text-light&#x27;,
      8: &#x27;bg-orange-200 text-orange-900&#x27;,
      16: &#x27;bg-orange-300 text-orange-900&#x27;,
      32: &#x27;bg-red-300 text-red-900&#x27;,
      64: &#x27;bg-red-400 text-white&#x27;,
      128: &#x27;bg-yellow-300 text-yellow-900&#x27;,
      256: &#x27;bg-yellow-400 text-yellow-900&#x27;,
      512: &#x27;bg-yellow-500 text-white&#x27;,
      1024: &#x27;bg-purple-500 text-white&#x27;,
      2048: &#x27;bg-purple-600 text-white&#x27;,
      4096: &#x27;bg-pink-500 text-white&#x27;
    };

    return colors[value] || &#x27;bg-pink-600 text-white&#x27;;
  }

  /**
   * Gérer les contrôles du jeu via le clavier
   * @param event
   * @private
   */
  private handleGameControls(event: KeyboardEvent): void {
    const moveMap &#x3D; new Map([
      [&#x27;ArrowUp&#x27;, () &#x3D;&gt; this.move(&#x27;up&#x27;)],
      [&#x27;ArrowDown&#x27;, () &#x3D;&gt; this.move(&#x27;down&#x27;)],
      [&#x27;ArrowLeft&#x27;, () &#x3D;&gt; this.move(&#x27;left&#x27;)],
      [&#x27;ArrowRight&#x27;, () &#x3D;&gt; this.move(&#x27;right&#x27;)],
      [&#x27;w&#x27;, () &#x3D;&gt; this.move(&#x27;up&#x27;)],
      [&#x27;s&#x27;, () &#x3D;&gt; this.move(&#x27;down&#x27;)],
      [&#x27;a&#x27;, () &#x3D;&gt; this.move(&#x27;left&#x27;)],
      [&#x27;d&#x27;, () &#x3D;&gt; this.move(&#x27;right&#x27;)]
    ]);

    const action &#x3D; moveMap.get(event.key);
    if (action) {
      event.preventDefault();
      action();
      return;
    }

    this.handleSpecialKeys(event);
  }

  /**
   * Gérer les touches spéciales pour les actions du jeu
   * @param event
   * @private
   */
  private handleSpecialKeys(event: KeyboardEvent): void {
    switch (event.key) {
      case &#x27; &#x27;:
        event.preventDefault();
        this.toggleGame();
        break;
      case &#x27;r&#x27;:
      case &#x27;R&#x27;:
        event.preventDefault();
        this.resetGame();
        break;
      case &#x27;u&#x27;:
      case &#x27;U&#x27;:
        event.preventDefault();
        this.undoMove();
        break;
      case &#x27;F12&#x27;:
        event.preventDefault();
        this.showDebug.set(!this.showDebug());
        break;
    }
  }

  /**
   * Effectuer le déplacement dans la direction spécifiée
   * @param direction
   * @returns
   */
  private performMove(direction: &#x27;up&#x27; | &#x27;down&#x27; | &#x27;left&#x27; | &#x27;right&#x27;): boolean {
    const currentBoard &#x3D; this.board();
    const newBoard &#x3D; this.copyBoard(currentBoard);

    const moveStrategies &#x3D; {
      left: () &#x3D;&gt; this.moveLeft(newBoard),
      right: () &#x3D;&gt; this.moveRight(newBoard),
      up: () &#x3D;&gt; this.moveUp(newBoard),
      down: () &#x3D;&gt; this.moveDown(newBoard)
    };

    const result &#x3D; moveStrategies[direction]();

    if (result.moved) {
      this.board.set(newBoard);
      this.score.update(s &#x3D;&gt; s + result.scoreGain);
    }

    return result.moved;
  }

  /**
   * Déplacer les tuiles vers la gauche
   * @param board
   * @private
   */
  private moveLeft(board: Cell[][]): { moved: boolean; scoreGain: number } {
    let moved &#x3D; false;
    let scoreGain &#x3D; 0;

    for (let row &#x3D; 0; row &lt; this.gridSize; row++) {
      const result &#x3D; this.processRow(board[row]);

      if (result.moved) {
        moved &#x3D; true;
      }

      scoreGain +&#x3D; result.scoreGain;
      board[row] &#x3D; result.newRow;
    }

    return { moved, scoreGain };
  }

  /**
   * Traiter une ligne pour le déplacement et la fusion
   * @param row
   * @private
   */
  private processRow(row: Cell[]): { newRow: Cell[]; moved: boolean; scoreGain: number } {
    const filteredRow &#x3D; this.filterNonEmptyCells(row);
    const mergeResult &#x3D; this.mergeRow(filteredRow);
    const paddedRow &#x3D; this.padRowWithEmptyCells(mergeResult.mergedRow);

    return {
      newRow: paddedRow,
      moved: this.hasRowChanged(row, paddedRow),
      scoreGain: mergeResult.scoreGain
    };
  }

  /**
   * Filtrer les cellules non vides d&#x27;une ligne
   * @param row
   * @private
   */
  private filterNonEmptyCells(row: Cell[]): Cell[] {
    return row.filter(cell &#x3D;&gt; cell.value !&#x3D;&#x3D; 0);
  }

  /**
   * Fusionner les cellules adjacentes de même valeur dans une ligne
   * @param row
   * @private
   */
  private mergeRow(row: Cell[]): { mergedRow: Cell[]; scoreGain: number } {
    const newRow: Cell[] &#x3D; [];
    let scoreGain &#x3D; 0;

    for (let i &#x3D; 0; i &lt; row.length; i++) {
      const current &#x3D; row[i];
      const next &#x3D; row[i + 1];

      if (next &amp;&amp; current.value &#x3D;&#x3D;&#x3D; next.value &amp;&amp; !current.merged &amp;&amp; !next.merged) {
        const mergedCell: Cell &#x3D; {
          value: current.value * 2,
          id: this.getNextCellId(),
          merged: true
        };
        newRow.push(mergedCell);
        scoreGain +&#x3D; mergedCell.value;
        i++; // Skip next cell
      } else {
        newRow.push({ ...current, merged: false });
      }
    }

    return { mergedRow: newRow, scoreGain };
  }

  /**
   * Compléter une ligne avec des cellules vides pour atteindre la taille de la grille
   * @param row
   * @private
   */
  private padRowWithEmptyCells(row: Cell[]): Cell[] {
    const paddedRow &#x3D; [...row];
    while (paddedRow.length &lt; this.gridSize) {
      paddedRow.push({ value: 0, id: this.getNextCellId() });
    }
    return paddedRow;
  }

  /**
   * Vérifier si une ligne a changé après un déplacement ou une fusion
   * @param originalRow
   * @param newRow
   * @private
   */
  private hasRowChanged(originalRow: Cell[], newRow: Cell[]): boolean {
    return JSON.stringify(originalRow) !&#x3D;&#x3D; JSON.stringify(newRow);
  }

  /**
   * Déplacer les tuiles vers la droite
   * @param board
   * @private
   */
  private moveRight(board: Cell[][]): { moved: boolean; scoreGain: number } {
    // Inverser, déplacer à gauche, puis inverser à nouveau
    this.reverseRows(board);
    const result &#x3D; this.moveLeft(board);
    this.reverseRows(board);
    return result;
  }

  /**
   * Déplacer les tuiles vers le haut
   * @param board
   * @private
   */
  private moveUp(board: Cell[][]): { moved: boolean; scoreGain: number } {
    this.transpose(board);
    const result &#x3D; this.moveLeft(board);
    this.transpose(board);
    return result;
  }

  /**
   * Déplacer les tuiles vers le bas
   * @param board
   * @private
   */
  private moveDown(board: Cell[][]): { moved: boolean; scoreGain: number } {
    this.transpose(board);
    this.reverseRows(board);
    const result &#x3D; this.moveLeft(board);
    this.reverseRows(board);
    this.transpose(board);
    return result;
  }

  /**
   * Créer un plateau vide
   * @private
   */
  private createEmptyBoard(): Cell[][] {
    return Array(this.gridSize).fill(null).map(() &#x3D;&gt;
      Array(this.gridSize).fill(null).map(() &#x3D;&gt; ({
        value: 0,
        id: this.getNextCellId()
      }))
    );
  }

  /**
   * Copier un plateau
   * @param board
   * @private
   */
  private copyBoard(board: Cell[][]): Cell[][] {
    return board.map(row &#x3D;&gt;
      row.map(cell &#x3D;&gt; ({ ...cell }))
    );
  }

  /**
   * Vérifier s&#x27;il y a des mouvements disponibles
   * @private
   */
  private hasAvailableMoves(): boolean {
    const currentBoard &#x3D; this.board();

    for (let row &#x3D; 0; row &lt; this.gridSize; row++) {
      for (let col &#x3D; 0; col &lt; this.gridSize; col++) {
        const current &#x3D; currentBoard[row][col].value;

        // Vérifier les cellules adjacentes
        if (
          (col &lt; this.gridSize - 1 &amp;&amp; current &#x3D;&#x3D;&#x3D; currentBoard[row][col + 1].value) ||
          (row &lt; this.gridSize - 1 &amp;&amp; current &#x3D;&#x3D;&#x3D; currentBoard[row + 1][col].value)
        ) {
          return true;
        }
      }
    }

    return false;
  }

  /**
   * Transposer le plateau (échanger lignes et colonnes)
   * @param board
   * @private
   */
  private transpose(board: Cell[][]): void {
    for (let i &#x3D; 0; i &lt; this.gridSize; i++) {
      for (let j &#x3D; i + 1; j &lt; this.gridSize; j++) {
        [board[i][j], board[j][i]] &#x3D; [board[j][i], board[i][j]];
      }
    }
  }

  /**
   * Inverser les lignes du plateau
   * @param board
   * @private
   */
  private reverseRows(board: Cell[][]): void {
    board.forEach(row &#x3D;&gt; row.reverse());
  }

  /**
   * Sauvegarder l&#x27;état actuel pour permettre l&#x27;annulation
   * @private
   */
  private saveCurrentState(): void {
    this.previousState &#x3D; {
      board: this.copyBoard(this.board()),
      score: this.score(),
      moves: this.moves(),
      canUndo: true
    };
  }

  /**
   * Obtenir le prochain ID unique pour une cellule
   * @private
   */
  private getNextCellId(): number {
    return ++this.cellIdCounter;
  }

  /**
   * Charger le meilleur score depuis le stockage local
   * @private
   */
  private loadBestScore() {
    const saved &#x3D; localStorage.getItem(&#x27;2048BestScore&#x27;);
    this.bestScore.set(saved ? parseInt(saved) : 0);
  }

  /**
   * Sauvegarder le meilleur score dans le stockage local
   * @private
   */
  private saveBestScore() {
    localStorage.setItem(&#x27;2048BestScore&#x27;, this.bestScore().toString());
  }
}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'Cell.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
